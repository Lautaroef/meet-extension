# Task ID: 19
# Title: Backend Services for Chrome Extension (Next.js)
# Status: pending
# Dependencies: 16, 6
# Priority: medium
# Description: Develop and manage all backend API endpoints and WebSocket services within the Next.js application that the Chrome Extension will interact with. This includes services for pre-meeting summaries, AI model interactions (OpenAI STT via proxy, Gemini analysis), and ephemeral token generation.
# Details:
Implement and maintain secure backend services for the Chrome Extension within the Next.js application. This includes:
1.  **Pre-meeting Summary API:** An endpoint (e.g., `/api/meetings/:meetingId/summary`) to fetch generated summaries (from Task 16).
2.  **OpenAI STT Proxy:** An endpoint to securely proxy requests from the extension to the OpenAI STT service.
3.  **Gemini Analysis Service:** An endpoint or service to handle requests for Gemini-based analysis.
4.  **Ephemeral Token Generation:** An endpoint to generate short-lived tokens for specific extension operations.
5.  **Authentication:** Ensure all endpoints and services securely authenticate requests originating from the Chrome extension (e.g., using user session tokens or API keys).
6.  **Data Handling:** Interact with Supabase or other data stores as needed for retrieving/storing relevant information.

# Test Strategy:
Test each API endpoint individually with valid/invalid inputs, authentication scenarios (success/failure), and edge cases. Verify correct data handling and interaction with external services (OpenAI, Gemini, Supabase). Test the ephemeral token generation and validation flow. Implement integration tests simulating Chrome Extension interactions. Monitor performance and response times for all services.

# Subtasks:
## 1. Implement API Endpoint for Pre-Meeting Summaries [pending]
### Dependencies: None
### Description: Create a Next.js API endpoint (e.g., `/api/meetings/[meetingId]/summary`) that the Chrome extension can call to fetch pre-meeting summary content. This content is assumed to be generated by Task 16 and stored appropriately (e.g., in Supabase).
### Details:
1. Define the API route in the Next.js backend (`src/app/api/meetings/[meetingId]/summary/route.ts`).
2. Implement logic to retrieve pre-meeting summary data based on `meetingId` (this data would have been generated and stored by processes related to Task 16).
3. Ensure the endpoint is authenticated to verify requests from the Chrome extension (e.g., using session tokens or a dedicated API key for the extension).
4. Return the summary data in a structured JSON format.

## 2. Implement API Endpoint for OpenAI Ephemeral Token Generation [done]
### Dependencies: None
### Description: Create a Next.js API endpoint (e.g., `/api/openai/create-transcription-session`) that the Chrome extension calls to get an ephemeral token for OpenAI Realtime API.
### Details:
1. Define the API route (e.g., `src/app/api/openai/create-transcription-session/route.ts`).
2. This endpoint will use the server-side OpenAI API key (stored securely as an environment variable).
3. It makes a POST request to OpenAI's `https://api.openai.com/v1/realtime/transcription_sessions` endpoint.
   - Include the `Authorization: Bearer <SERVER_OPENAI_API_KEY>` and `OpenAI-Beta: assistants=v2` headers (Note: the 'assistants=v2' beta header was mentioned in an example for creating sessions; confirm if 'realtime=v1' or another is needed for *this specific* session creation endpoint if different from the WebSocket beta header).
   - The payload should include necessary parameters like `input_audio_format: 'pcm16'`, `input_audio_transcription: { model: 'gpt-4o-transcribe', language: 'en' }`, and `turn_detection` settings, potentially configurable via query params from the extension's request if needed.
4. Extract the `client_secret.value` (ephemeral token) from OpenAI's response.
5. Return this ephemeral token to the Chrome extension in a JSON response.
6. Implement error handling for the call to OpenAI.

## 3. Implement WebSocket Proxy for OpenAI Realtime Transcription [in-progress]
### Dependencies: None
### Description: Implement a WebSocket endpoint in the Next.js backend (e.g., `/api/transcribe-socket`) that proxies communication between the Chrome Extension and the OpenAI Realtime Transcription API.
### Details:
1. Set up a WebSocket server on the Next.js backend (e.g., using `ws` library or Next.js specific WebSocket solution if available for App Router route handlers).
2. When a Chrome extension client connects:
   a. Expect an `init_transcription` message from the client with desired OpenAI parameters (language, model, etc.).
   b. Use Subtask 19.2 (or call its logic directly) to obtain an ephemeral token for OpenAI.
   c. Establish a new WebSocket connection from the backend to OpenAI (`wss://api.openai.com/v1/realtime?intent=transcription`) using the ephemeral token and `OpenAI-Beta: realtime=v1` header.
   d. Send the `transcription_session.update` message to OpenAI, configured with parameters from the client's `init_transcription` message and `input_audio_format: 'pcm16'`.
3. Proxying Logic:
   a. On receiving audio data (e.g., Base64 string in a `{ type: 'audio_chunk', data: '...' }` message) from the extension: Decode Base64 to binary (if OpenAI server-side WS doesn't accept Base64 directly for `input_audio_buffer.append`). Forward the audio data to the OpenAI WebSocket (e.g., as `{ type: 'input_audio_buffer.append', audio: 'base64_encoded_chunk' }` if OpenAI expects Base64, or raw binary if that's how the server-side SDK works).
   b. On receiving transcription event messages (delta, completed) from OpenAI: Forward these messages to the connected Chrome extension client.
4. Handle disconnections and errors gracefully for both client-to-backend and backend-to-OpenAI WebSockets. Manage state for multiple concurrent extension clients if applicable.

## 4. Implement Backend API for Gemini Text Analysis [pending]
### Dependencies: None
### Description: Create a general-purpose Next.js API endpoint (e.g., `/api/gemini/analyze-text`) that the Chrome extension can call for various text analysis tasks using the Gemini API.
### Details:
1. Define the API route (e.g., `src/app/api/gemini/analyze-text/route.ts`).
2. This endpoint will use the server-side Google API key (stored securely as an environment variable).
3. Accept a POST request from the extension containing:
    a. `text_input`: The text to be analyzed (e.g., transcript segment, user query).
    b. `prompt_instructions`: Specific instructions for the Gemini model (e.g., "Summarize this text for key takeaways," "Identify action items," "Answer this question based on the provided context.").
    c. `response_schema` (optional): A JSON schema definition if structured output is required from Gemini (as per Gemini's structured output guide).
4. Call the Gemini API (e.g., `generateContent` using the appropriate Gemini model like `gemini-2.0-flash` or a `gemini-2.5-pro` variant if needed for complexity) with the provided text, instructions, and schema.
5. Return Gemini's response (ideally the structured JSON if a schema was provided, or plain text otherwise) to the Chrome extension.
6. Implement error handling for the call to Gemini API.

## 5. Implement/Refactor Authentication for Extension Backend Services [pending]
### Dependencies: None
### Description: Ensure a consistent and secure authentication mechanism (e.g., session token validation, or a dedicated API key for the extension) is applied across all backend API endpoints and WebSocket services intended for Chrome Extension use.
### Details:
1. Evaluate existing authentication/session management in the Next.js app (if any, from Task 6 user auth).
2. Decide on the authentication strategy for extension-to-backend communication (e.g., reuse user session tokens if the user is logged into the webapp and the extension can access this token securely, or issue a separate, securely stored API key/token specifically for the extension).
3. Implement Next.js middleware or individual endpoint checks to validate the token/key for all relevant API routes and WebSocket upgrade requests under `/api/*` that are used by the extension.
4. Ensure unauthorized requests are rejected appropriately.

